# Idris2-dom: A Tutorial

In this tutorial I am going to explain the core functionality
provided by this library and shed some light on implementation
details, design decisions, and the module structure of
idris2-dom. This whole thing is still evolving - as is Idris2 itself -
so expect stuff to change frequently until things settle down
a bit.

## Before we begin: Some background

Most of the several thousands of lines of codes in this library have
been automatically generated by the
[idris2-webidl](https://github.com/stefan-hoeck/idris2-webidl)
program from a set of [Web IDL](https://en.wikipedia.org/wiki/Web_IDL)
specifications, collected from several resources on the
internet. You can find the specs used in the `idl` folder
of the idris2-webidl project.

The generated code consists of a set of external type
declarations (to be found in the submoduls of
`Web.Internal` whose names end on `Type.idr`). This was done to
avoid cyclic module dependencies, since many of these types
are freely shared across specifications and the related
modules. The whole set of external types is reexported
by `Web.Internal.Types`, which also includes the subtyping
relations (more on that later).

FFI bindings are defined in submodules of `Web.Internal` ending on `Prim.idr`.
If you are interested in how to interact with javascript through the FFI,
you will find many examples there.

The actual API of this library is provided by the
modules in `Web.Raw`, which provide a convenience layer around
the FFI primitives.

Finally, direct submodules of `Web` add yet another layer of
safety and convenience. Unlike the modules in `Web.Internal` and `Web.Raw`,
these are hand-written and still lacking a lot of functionality.

All of the above rely on a set of utility functions and types provided
by the submodules in folder `src/JS` and reexported by module `JS`
itself. This includes interfaces for converting values from and to
their FFI representation, utilities for subtyping and safe casts, nullable
and undefined values, plus a set of integral types, which are represented
by Javascript `Number`s in the backend, unlike the Idris2 integer primitives,
which all are bound to `BigInt` (although this might change in the
future).

It is the goal of this tutorial to explain how all these pieces
fit together.

## A first example

Below is the logic of a simple web page consisting of a
button and a text field. Users can enter their name in
the text field and receive a friendly greeting upon clicking
the button. At the same time, during text input, the program
checks whether the name entered is a palindrome or not.

```idris
module Doc.Tutorial

import Data.String
import JS
import Web.Dom
import Web.Html
import Web.Raw.UIEvents

checkPalindrome : String -> String
checkPalindrome s =
  let s' = toLower s
   in if s' == reverse s'
         then "Cool! Your name is a palindrome."
         else "Your name is rather mundane..."

export
prog : JSIO ()
prog = do btn <- createElement Button
          textContent btn .= "Click me!"
          Element.id btn .= "the_button"

          txt <- newElement Input [ type =. "text"
                                  , placeholder =. "Enter your name here."
                                  ]

          txtDiv <- createElement Div
          lenDiv <- createElement Div
          outDiv <- createElement Div

          onclick btn ?> do name <- txt `get` value
                            textContent outDiv .= #"Hello \#{name}!"#

          oninput txt ?> do reply <- checkPalindrome `over` value txt
                            textContent lenDiv .= reply

          ignore $ (!body `appendChild` btn)    *>
                   (!body `appendChild` txtDiv) *>
                   (!body `appendChild` outDiv) *>
                   (!body `appendChild` lenDiv) *>
                   (txtDiv `appendChild` txt)
```

You can give this a try in the browser by replacing the
`main` function in `Doc.Main` with `main = runJS Doc.Tutorial.prog`
followed by building the `doc` package: `idris2 --build doc.ipkg`.
Now, load the `doc.html` file in the project's root folder in your browser.
It will not look very nice, but it should behave as described.

## Step-by-step program walkthrough

### The `JSIO` monad
The program is of type `JSIO ()`, which is just an alias for
`EitherT JSErr IO ()`. Since the world of Javascript is highly unsafe,
error handling comes built-in in the default IO monad we use (however, we do
not catch a lot of errors so far).
The error type `JSErr` is defined in module `JS.Util` and reexported
by module `JS`, which provides the core types and functionality
required for interacting with the world of Javascript.

In order to run a program of type `JSIO ()`, we need a way to
deal with the possibility of errors. The most basic option
is function `runJS`, which logs any error to the console
(function `JS.Util.consoleLog`). `MonadError` exported by
`Control.Monad.Either` in `base` provides additional functionality
for error handling.

### Programmatically creating HTML elements

Function `Web.Dom.createElement` takes a tag from an enum type
and returns a properly typed, newly created HTML element.
This is a convenient wrapper around the automatically generated
`Web.Raw.Dom.Document.createElement`. In addition,
`Web.Dom.newElement` takes an additional list of modifiers
for adjusting the newly created element. This is especially
useful for setting an element's attributes (see also the section
about `Attribute`s below).

This is probably the right place to explain how safe type casts
are handled in this library. There are mainly two ways to inspect
the type of a value at runtime in Javascript: One is function
`typeof`, a binding to which is available in `JS.Util`. This
function is mostly useful to figure out the types of primitives
like numbers and strings. For other types like `HTMLElement`, which
also inherits methods and attributes from `Node` and `Object`
(and some others), it is necessary to inspect
the chain of prototype objects to figure out, from which
types a value inherits its functionality.

External types, whose type can be verified at runtime by one of
the two means described above, implement interface
`SafeCast` from module `JS.Inheritance`. This module also provides
the two main (unsafe) functions to inspect and change a value's type at runtime
plus some utility functions.
Please note, that `SafeCast` is meant to be used for external types only.
Note also, that `SafeCast` is typically not the thing you want
for upcasting (that is, casting a type to one of its parent
types or included mixins): For this, there is another interface,
which will be desribed below.

As an example: In the program above, we know that the element
with id "the_button" is a `HTMLButtonElement`. However,
function `getElementById` from `Web.Raw.Dom` returns a `Maybe Element`.
If we'd like to disable this button, we first have to cast it to
the proper type. We can use `safeCast` for this:

```idris
export
disableBtn : JSIO ()
disableBtn = do maybeElem <- getElementById !document "the_button"
                let maybeBtn = maybeElem >>= safeCast {a = HTMLButtonElement} 
                for_ maybeBtn \btn => do disabled btn .= True
                                         consoleLog "Disabled button"
```

You can try the action above by modifying our original
program:

```
main = runJS $ prog *> disableBtn
```

Since looking up an element and refining its type by downcasting
is a common pattern, there is function `castElementById` in `Web.Dom`:

```idris
export
disableBtn2 : JSIO ()
disableBtn2 = do maybeBtn <- castElementById HTMLButtonElement "the_button"
                 for_ maybeBtn $ disabled =. True
```

### Attributes

Attributes are amongst the most common members of Web IDL definitions.
In this section, we are talking about non-static read/write attributes.
Readonly attributes are mapped to plain functions in this library.
Read/write attributes, however, are represented by an indexed
data type and come with quite a few utility functions and operators.
All of this is provided by module `JS.Attribute`. Lets have a look
at how all of this works under the hood.

All flavors of `JS.Attribute.Attribute` consist of a
getter (of type `JSIO $ f a` for a context `f` and return type `a`)
and a setter (of type `f a -> JSIO ()`). They differ in the context,
in which a value is wrapped (`I` if the attribute is mandatory
and non-nullable, `Maybe` if it is mandatory but possibly `null`,
and `Optional`, if the attribute might be missing altogether, in
which case the getter at the FFI returns `undefined`), as well as
whether it is possible to always get a concrete value when invoking
the getter (this is even possible for optional attributes, if
they have a default value defined in the specification).

Although the Javascript constants `null` and `undefined` both describe
a missing value, they can - depending on context - still have different
semantics, therefore we use two different pairs of Idris2 types to deal with
them. In foreign function calls, nullable values are represented
by external type `Nullable a` from `JS.Nullable`, which is converted to `Maybe a`
in the `*Raw` modules. Optional attributes and function arguments
are represented by the external type `UndefOr a` at the FFI and
marshalled from and to `Optional a`, a monadic type isomorphic to
`Maybe a`. `UndefOr` and `Optional` are both defined in `JS.Undefined`.

The `JS.Attribute` modules provides some utility functions and operators
for accessing and updating the value stored in an attribute.
New operators are always a delicate topic, so this module only adds six
of them. `(.=)` is an infix version of `set`, as is `(=.)`, which
is useful when the object, to which an attribute belongs, is stored
in a traversable structure. Likewise, `(%=)` modifies an attribute's
stored value, and `(=%)` is again the flipped variant.
Finally, there are two operators `(!>)` and `(?>)` use for registering
callback functions, a topic discussed in more detail below.

### Interlude: Marshalling values between the FFI and Idris2

Idris values can typically not be used directly in FFI calls.
To marshall between the worlds of raw Javascript and Idris, two
interfaces are provided by `JS.Marshall`: `ToFFI` and `FromFFI`.
Both interfaces take two type parameters, the first being an
Idris type, the second its external representation. As
an example, consider the following `Answer` data type:

```idris
data Answer = Yes | No
```

Values of type `Answer` should be represented by Javascript booleans,
for which there already is an external type: `JS.Boolean.Boolean`, which
also provides values for the Javascript constants `true` and `false`.

It is therefore straight forward to implement `ToFFI` for `Answer`:

```idris
ToFFI Answer Boolean where
  toFFI Yes = true
  toFFI No  = false
```

Note, that conversions to the FFI should always succeed as types in Idris
are considered to be more precise than the ones used in the backend.

Coming from the backend is only slightly more involved. First, the
conversion might fail (this shouldn't happen if functions implemented
in Javascript adhere to their spec, but one can never know for sure),
so we return a `Maybe`. In addition, we have to compare the FFI value
against the external constants. For this, heterogeneous equality
function `JS.Util.eqv` can be used,
which invokes the Javascript `===` operator internally. Here's the
implementation of `FromFFI`:

```idris
FromFFI Answer Boolean where
  fromFFI v = if eqv v true then Just Yes
              else if eqv v false then Just No
              else Nothing
```

Most of the time, foreign function calls wrap their result in `PrimIO`.
Values wrapped this way can be converted to their Idris representation
by means of `JS.Marshall.tryJS`. This function takes an additional
`String`, which will be used to specify the call site in the
error in case the conversion fails:

```idris
%foreign "javascript:lambda:x => { console.log(x); return x > 0; }"
prim__logAndTest : Double -> PrimIO Boolean

logAndTest : Double -> JSIO Answer
logAndTest d = tryJS "Doc.Tutorial.logAndTest" $ prim__logAndTest d
```

### Callbacks

For some types it is harder to write generic conversion
functions. This is especially the case for callbacks, which
are for instance used as event listeners in browser elements.
Like most Web IDL definitions, callbacks get their own external
type (see for instance `Web.Internal.DomTypes.EventListener`).
However, it is not possible to directly write a `ToFFI` implementation
for the corresponding Idris function for two reasons: First, interface
resolution does not work for function types (but see below), and
second, converting an Idris function to a callback is not referentially
transparent, since each conversion will create a new Javascript
function object.

Therefore, we need a new interface for handling this corner case:
`JS.Callback.Callback`. Automatically generating instances of this
interface with proper marshalling proved to be hard,
and since there are not many callbacks
defined in the specs, I chose to implement these manually.

Note, how interface resolution for `Callback` is based on the
external type, so it is no problem that the second type is an
Idris function.

Attributes come with two utility operators for registering
callbacks: `(!>)` allows us to register a unary callback function
while `(?>)` registers an action which ignores the value passed to it.
The following code snippets provides examples for both use cases:

```idris
complainOnClick : HTMLButtonElement -> JSIO ()
complainOnClick btn = onclick btn ?> consoleLog "Don't touch me!"

doComplain : Event -> JSIO ()
doComplain e = do me <- tryCast_ MouseEvent "doComplain" e
                  shiftPressed <- shiftKey me
                  if shiftPressed
                     then consoleLog "DON'T TOUCH ME!"
                     else consoleLog "Don't touch me!"

complainSomeMore : HTMLButtonElement -> JSIO ()
complainSomeMore btn = onclick btn !> doComplain
```
