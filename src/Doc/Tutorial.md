## Idris2-dom: A Tutorial

In this tutorial I am going to explain the core functionality
provided by this library and shed some light on implementation
details, design decisions, and the module structure of
this library. This whole thing is still evolving - as is Idris2 itself -
so expect things to change frequently until things settle down
a bit.

### Before we begin: Some background

Most of the several thousands of lines of codes in this library have
been automatically generated by the
[idris2-webidl](https://github.com/stefan-hoeck/idris2-webidl)
program from a set of [Web IDL](https://en.wikipedia.org/wiki/Web_IDL)
specifications, collected from several resources on the
internet. You can find the specs used in the `idl` folder
of the idris2-webidl project.

The generated code consists of a set of external type
specifications (to be found in the submoduls of
`Web.Internal` whose names end on `Type.idr`). This was done to
avoid cyclic module dependencies, since many of these types
are freely shared across specifications and the related
modules. The whole set of external types is reexported
by `Web.Internal.Types`.

FFI bindings are defined in submoduls of `Web.Internal` ending on `Prim.idr`.
If you are interested in how to interact with javascript through the FFI,
you will find lots of examples there.

The actual API of this library is provided by the
modules in `Web.Raw`, which provide a convenience layer around
the FFI primitives. Many of these functions can be conveniently
used out of the box.

Finally, direct submodules of `Web` add yet another layer of
safety and convenience. Unlike the modules in `Web.Internal` and `Web.Raw`,
these are hand-written and still lacking a lot of functionality.

All of the above rely on a set of utility functions and types provided
by the submodules in folder `src/JS` and reexported by module `JS`
itself. This includes interfaces for converting values from and to
their FFI representation, subtyping and safe casts, nullable
and undefined values, plus a set of integral types, which are represented
by Javascript `Number`s in the backend, unlike the Idris2 integer primitives,
which all are bound to `BigInt`.

It is the goal of this tutorial, to explain how all these pieces
fit together.

### A first example

Below is the logic of a simple web page consisting of a
button and a text field. Users can enter their name in
the text field and receive a friendly greeting upon clicking
the butten. At the same time, during text input, the program
checks whether the name entered is a palindrome.

```idris
module Doc.Tutorial

import Data.String
import JS
import Web.Dom
import Web.Html

checkPalindrome : String -> String
checkPalindrome s =
  let s' = toLower s
   in if s' == reverse s'
         then "Cool! Your name is a palindrome."
         else "Your name is rather mundane..."

export
prog : JSIO ()
prog = do btn <- createElement Button
          textContent btn .= "Click me!"

          txt <- createElement Input
          type txt .= the String "text"
          placeholder txt .= "Enter your name here."

          txtDiv <- createElement Div
          lenDiv <- createElement Div
          outDiv <- createElement Div

          onclick btn ?> do name <- txt `get` value
                            textContent outDiv .= #"Hello \#{name}!"#

          oninput txt ?> do reply <- checkPalindrome `over` value txt
                            textContent lenDiv .= reply

          ignore $ (!body `appendChild` btn)    *>
                   (!body `appendChild` txtDiv) *>
                   (!body `appendChild` outDiv) *>
                   (!body `appendChild` lenDiv) *>
                   (txtDiv `appendChild` txt)
```

You can give this a try in the browser, by replacing the
`main` function in `Doc.Main` with `main = runJS Doc.Tutorial.prog`
followed by building the `doc` package: `idris2 --build doc.ipkg`.
Now, load `doc.html` in the project's root folder in your browser.
It will not look very nice, but it should behave as described.

## Step-by-step program walkthrough

### The `JSIO` monad
The program is of type `JSIO ()`, which is just an alias for
`EitherT JSErr IO ()`. Since the world of Javascript is highly unsafe,
error handling comes built-in in the default IO monad we use.
The error type `JSErr` is defined in module `JS.Util` and reexported
by module `JS`, which provides the core types and functionality
required for interacting with the world of Javascript.

In order to run a program of type `JSIO ()`, we need a way to
deal with the possibility of errors. The most basic option
is function `runJS`, which logs any error to the console
(function `JS.Util.consoleLog`). Note, that the modules found
in `Control.Monad.Error` in `base` provide additional functionality
for error handling.

### Programmatically creating HTML elements

Function `Web.Dom.createElement` takes a tag from an enum type
and returns a properly typed, newly created html element.
This is a safer wrapper around `Web.Raw.Dom.Document.createElement`.

This is probably the right place to explain how to try and safely cast
one Javascript external type to another one.
